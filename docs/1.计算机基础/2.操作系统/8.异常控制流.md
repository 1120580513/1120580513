# 异常控制流 ECF Exceptional Control Flow

## 异常

> 当处理器检测到事件发生时，通过异常表(exception table)的跳转表，进行一个间接过程调用到异常处理程序(exception handler)

- 类别
  - 中断 来自I/O设备的信号 异步 例如网络适配器向处理器芯片的一个引脚发信号，并把异常号放到系统总线上
  - 陷阱 有意的异常 同步 主要是在用户程序和内核之间提供一个接口，也叫系统调用
    - 比如用户程序，读取一个文件，创建一个进程，加载一个程序，此时执行处理器提供的 syscall n，导致陷阱处理程序的运行
    - 用户的函数运行在用户模式，而系统调用运行在内核模式中
  - 故障 潜在可恢复的错误 同步
    - 如缺页异常，当指令引用的虚拟内存对应的物理页面不在内存中时，会发生故障，处理程序会从磁盘中加载
    - 如果处理程序不能修复这个问题，将返回到 abort 例程，abort 将终止应用程序
  - 终止 不可恢复的错误 同步
    - 如 RDAM 或 SRAM 位被损坏时
    - 直接交给 abort，abort 会终止应用程序

## 信号

> 更高层次的软件形式的异常，允许进程和内核中断其他进程

> 一种类型的信号只会有一个待处理信号，再次发送的将被丢弃（内核通过位向量来维护）

> 信号处理程序是和主程序和其他信号处理程序并发运行的

> 系统调用可以被信号中断，read/write/accept 这样的慢速系统调用时发生，如果因信号而中断，那么将不再继续而是返回错误，代码必须手动重启

- 发送信号 内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程
  - 内核检测到一个系统事件，比如除零错误或子进程终止
  - 一个进程调用了 kill 函数，显式的要求内核发送一个信号给目的进程
  - 常见的发送方式 
    - /bin/kill -9 15213 向 15231 进程组中的进程发送 9（SIGKILL）
    - Ctrl + C 发送 SIGINT
    - Ctrl + Z 发送 SIGTSTP
- 接收信号 目的进程被内核强迫以某种方式对信号做出反应
  - 内核将进程从内核模式切换回用户模式时，检查是否有未被阻塞的未处理信号（通常是最小的），如果有则强制进程接收该信号
  - 终止或通过执行一个信号处理程序的用户层函数捕获这个信号
  - 每个信号都有默认行为，以下的一种（可以通过函数改变）
    - 进程终止
    - 进程终止并转储内存
    - 进程停止（挂起）走到被 SIGCONT 重启
    - 进程忽略该信号
- 待处理信号 发出而没有被接口的信号
- 阻塞的信号
  - 进程可以有选择的阻塞接收某种信号
  - 信号被阻塞时，它仍可以被发送，但产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞
  - 机制
    - 隐式阻塞机制 内核默认阻塞当前在处理信号类型的待处理信号
    - 显式阻塞 使用 sigprocmask 相关的函数，明确的阻塞和解除阻塞选定的信号

## 非本地跳转

> 一种用户级异常控制流形式，从一个函数转到另一个当前正在执行的函数，而不需要经过正常的调用-返回程序

> C++ 和 Java 的异常机制是较高层次的，可看成为 setjmp/longjmp 更加结构化的版本，把 try cache 看成 setjmp，throw 类似于 longjmp 函数

- setjmp 
  - 在 env 缓冲区保存当前的调用环境供 longjmp 使用，包括程序计数器、栈指针和通用目的寄存器
- longjmp
  - 从 env 中恢复调用环境，然后触发从最近一次的 setjmp 的调用的返回，此时 setjmp 返回并有非 0 的返回值（setjmp 返回了两次）
  - 注意，如果中间函数调用中分配了某些数据结构，本该在结尾释放，如果中间发生跳转，会造成内存泄漏
- sigsetjmp/siglongjmp 可被信号处理程序使用的版本
- 应用
  - 遇到一个错误时，从一个深层嵌套的函数调用中立即返回
  - 使一个信号处理程序分支到一个特殊的代码位置，比如实现 Ctrl + C 来中断信号处理程序
