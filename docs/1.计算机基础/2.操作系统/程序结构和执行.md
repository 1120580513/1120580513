# 程序结构和执行

## 信息的表示和处理

- **小端法** _最低有效字节在前面_
- **大端法** _最低有效字节在后面_
  **浮点数保存**

### 原码
> 最高位是符号位

### 反码
> 最高有效位是 -(2^w-1 -1)，1111 1111 1111 1111 1111 1111 1111 1111 => 0

### 补码
> 最高有效位是 -(2^w-1)，1111 1111 1111 1111 1111 1111 1111 1111 => -1

### 浮点数(IEEE 754 标准)

> V = (-1)^s * M * 2^E

* E：阶码
* M：尾数
* exp：阶码的位长
* frac：尾数的位长
* Bias：2 ^ exp - 1

> 单精度：exp = 8，frac = 23
> 双精度：exp = 11，frac = 51

#### 规格化
> E 的位不全为 0 也不全为 1，E = e - Bias（e 为阶码的值）

#### 非规格化
> E 的位全为 0，E = 1 - Bias

#### 特殊值
> E 的位全为 1

* 尾数全为 0 时表示无穷大，尾数 <> 0 时表示 NaN

#### 舍入

> 一般使用 向偶数舍入（向最接近的值舍入），在大多数情况下避免了统计偏差

#### example
```
-6.625
= -( 1 *2^2 + 1 *2^1 + 0 *2^0 + 1 *2^-1 + 0 *2^-2 + 1 *2^-3 )
= -( 110.101) 【二进制表示】
= -(1.10101) * 2 ^ 2【二进制表示】
= 1 127 + 2 10101 000000000000000000
= 1 10000001 10101 000000000000000000
```

## 目标文件的执行

```cpp
#include <stdio.h>

int main()
{
  printf("hello word\n");
  return 0;
}
```

### 从源文件到目标文件

1. hello.c _源文件，文本_
2. hello.i _预处理器(cpp)修改原文件(修改#开头的文件)，文本_
3. hello.s _编译器(ccl)将 hello.i 翻译成 hello.s,翻译成汇编语言，文本_
4. hello.o _汇编器(as)将 hello.s 翻译成机器语言指令并打包成可重定位目标程序的格式，二进制文件_
5. hello _链接器(ld)将程序中的外部函数的预编译的目标文件合并得到可执行程序，二进制文件_

### 目标文件的执行过程(无缓存)

1. CPU 执行 shell 的指令,等待用户输入字符
2. 输入 hello.exe(each in 'hello.exe'：USB -> I/O 总线 -> I/O 桥 -> 系统总线 -> 总线接口 -> 寄存器文件 -> 总线接口 -> 系统总线 -> I/O 桥 -> 主存储器)
3. 通过直接存储器读取文件,将 hello.exe 的代码和数据复制到主存(磁盘控制器 -> I/O 桥 -> 内存总线 -> 主存设备)
4. 执行 man 函数的机器语言指令,将"hello word\n"，从主存复制到寄存器文件，再从寄存器文件复制到显示设备

- > **系统花费大量时间把信息从一个地方挪到另一个地方,减慢了程序的"真正"工作**
- > 根据机械原理：**较大的存储设备要比较小的存储设备运行的慢,而快速设备的造价远高于同类的低速设备**
- > **处理器从寄存器文件中读数据要比从主存中读数据快的多的多**
- > 系统设计者采用了更小更快的存储设备(高速缓存存储器)
