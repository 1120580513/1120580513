# 操作系统

- **防止硬件被失控的应用程序滥用**
- **向而应用程序提供简单一致的机制来控制低级硬件设备**

> 操作系统通过进程、虚拟内存、文件来实现以上基本功能

## 进程

> 执行中程序的实例

- 进程提供给应用程序的关键抽象
  - 一个独立的逻辑控制流 好像程序独占地使用处理器
  - 一个私有的地址空间 好像程序独占地使用内存系统
- 逻辑控制流: PC 值的序列
- 进程上下文: 每个程序运行在一个进程上下文中，保存重启被抢占的进程所需的状态
  - 存放在内存的程序的代码和数据
  - 栈
  - 通用目的寄存器、浮点寄存器
  - 程序计数器
  - 环境变量
  - 打开文件描述符的集合等内核数据结构
- 抢占: 每个进程执行它的流的一部分，然后被抢占（暂时挂起）
- 时间片: 一个进程执行它的控制流的一部分的每一时间段
- 多任务/时间分片: 一个进程和其他进程轮流运行
- 并发: 逻辑流的执行在时间上与另一流重叠
- 并行: 两个流并发地运行在不同的处理器核或计算机上
- 用户模式和内核模式: 用某个寄存器的模式位实现，设置时为内核模式
  - 用户模式 
    - 不允许执行特权指令，如停止处理器，发起I/O操作，改变模式位
    - 不允许直接引用内核区的代码和数据
    - 必须通过系统调用接口间接的访问内核代码和数据
  - 内核模式
    - 应用程序必须使用中断、故障变为内核模式
    - linux 将许多内核数据结构的内容输入为用户可以读的文件层次结构（/proc）
- 调度: 进程执行时，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程
- 上下文切换: 调试时使用上下文切换，将控制转换到新线程
  - 内核使用的较高形式的异常控制流来实现多任务
  - 中断也可能会引发上下文切换，如周期性的定时器中断机制
  - 例
    - A进程执行系统调用read读取磁盘数据并陷入到内核
    - 内核此时代表进程A在用户模式下执行指令（没有单独的内核进程）
    - 陷阱处理程序请求磁盘的DMA数据
    - 内核代表，读取磁盘数据需要相对较长的时间，于是内核执行从A到B的上下文切换（内核从进程A的内核模式切换到进程B的内核模式），而不是什么都不干
    - 内核切换为用户模式，代表进程B执行指令
    - 磁盘发出中断信息，表示数据已传送到了内存
    - 内核判定进程B已运行足够的时间，执行从B到A的上下文切换
- 对应用来说进程的三种状态
  - 运行，要么在CPU上执行，要么在等待被执行且最终会被内核调度
  - 停止，线程的执行被挂起，且不会被调度
    - 当收到 SIGSTOP/SIGTSTP/SIGTTIN/SIGTTOU 进程就停止
    - 当收到 SIGCOUNT 时进程将再次运行
  - 终止
    - 从主程序返回
    - 调用 exit
    - 收到一个信号，该信号的默认行为是终止进程
- fork 父进程创建一个子进程
  - 子进程几乎与父进程一样，除了不同的 PID和私有的地址空间
  - 子进程终止时将保存在已终止状态，直到被父进程回收
    - 终止了但未被回收的进程称为僵死进程
  - 如果父进程终止那么内核会安排init进程代替父进程回收子进程
