# 操作系统

- **防止硬件被失控的应用程序滥用**
- **向而应用程序提供简单一致的机制来控制低级硬件设备**

> 操作系统通过进程、虚拟内存、文件来实现以上基本功能

## 进程

> 执行中程序的实例

- 进程提供给应用程序的关键抽象
  - 一个独立的逻辑控制流 好像程序独占地使用处理器
  - 一个私有的地址空间 好像程序独占地使用内存系统
- 逻辑控制流: PC 值的序列
- 进程上下文: 每个程序运行在一个进程上下文中，保存重启被抢占的进程所需的状态
  - 存放在内存的程序的代码和数据
  - 栈
  - 通用目的寄存器、浮点寄存器
  - 程序计数器
  - 环境变量
  - 打开文件描述符的集合等内核数据结构
- 抢占: 每个进程执行它的流的一部分，然后被抢占（暂时挂起）
- 时间片: 一个进程执行它的控制流的一部分的每一时间段
- 多任务/时间分片: 一个进程和其他进程轮流运行
- 并发: 逻辑流的执行在时间上与另一流重叠
- 并行: 两个流并发地运行在不同的处理器核或计算机上
- 用户模式和内核模式: 用某个寄存器的模式位实现，设置时为内核模式
  - 用户模式 
    - 不允许执行特权指令，如停止处理器，发起I/O操作，改变模式位
    - 不允许直接引用内核区的代码和数据
    - 必须通过系统调用接口间接的访问内核代码和数据
  - 内核模式
    - 应用程序必须使用中断、故障变为内核模式
    - linux 将许多内核数据结构的内容输入为用户可以读的文件层次结构（/proc）
- 调度: 进程执行时，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程
- 上下文切换: 调试时使用上下文切换，将控制转换到新线程
  - 内核使用的较高形式的异常控制流来实现多任务
  - 中断也可能会引发上下文切换，如周期性的定时器中断机制
  - 例
    - A进程执行系统调用read读取磁盘数据并陷入到内核
    - 内核此时代表进程A在用户模式下执行指令（没有单独的内核进程）
    - 陷阱处理程序请求磁盘的DMA数据
    - 内核代表，读取磁盘数据需要相对较长的时间，于是内核执行从A到B的上下文切换（内核从进程A的内核模式切换到进程B的内核模式），而不是什么都不干
    - 内核切换为用户模式，代表进程B执行指令
    - 磁盘发出中断信息，表示数据已传送到了内存
    - 内核判定进程B已运行足够的时间，执行从B到A的上下文切换
- 对应用来说进程的三种状态
  - 运行，要么在CPU上执行，要么在等待被执行且最终会被内核调度
  - 停止，线程的执行被挂起，且不会被调度
    - 当收到 SIGSTOP/SIGTSTP/SIGTTIN/SIGTTOU 进程就停止
    - 当收到 SIGCOUNT 时进程将再次运行
  - 终止
    - 从主程序返回
    - 调用 exit
    - 收到一个信号，该信号的默认行为是终止进程
- fork 父进程创建一个子进程
  - 子进程几乎与父进程一样，除了不同的 PID和私有的地址空间
  - 子进程终止时将保存在已终止状态，直到被父进程回收
    - 终止了但未被回收的进程称为僵死进程
  - 如果父进程终止那么内核会安排init进程代替父进程回收子进程

## 信息的表示和处理

- **小端法** _最低有效字节在前面_
- **大端法** _最低有效字节在后面_
---
- byte 字节: 8位，作为最小的可寻址的内存单位
- word size 字长: 虚拟地址以一个字来编码，决定虚拟地址空间大小
---
- Unicode: 文字编码标准
- UTF-8: 将每个字符编码为一个字节序列

### 整数有符号位的表示 

- 原码: 最高位表示符号位，人最容易理解
- 反码: 正数的反码是其本身，负数的反码是除符号位不变，其他位取反
- 补码: 正数的补码是其本身，负数的补码在反码的基础上 +1 

> 为了让加减乘除尽可能的简单，如加法转换为加一个负数，想到可以将符号位参与运算。此时原码直接计算是不正确的，而反码在表示 0 时会有两种情况，所以通常都使用补码。

> 整数运算实际上是一种模运算，表示数据的长度限制了取值的范围。

### 浮点籹 

- 二进制小数: 小数值是不精确的，只能通过增加长度来提高精度
  - 点的左边的位的权是2的正幂，右边的权是2的负幂
    - 101.11(二进制) = 4*1 + 2*0 + 1*1 + 1/2*1 + 1/4*1 = 5又3/4 = 5.75(十进制)
- IEEE(电气和电子工程师协会)浮点数
  - 公式: (-1)^s * M * 2^E
    - 符号(s): (-1)^s，决定这个数是正数还是负数
    - 阶码(exp): 2^E，可能是负数，对浮点数加权，权重是 2^E
    - 尾数(frac): M，二进制小数
    - s: 符号位
    - expa：k 位的阶码字段
    - frac：n 位的小数字段
    - Biasa: 2^(k-1) - 1
    - 被编码的值的三种情况(根据 exp 的值)
    - 规格化的: exp 的位即不都为 0 也不都为 1
      - E = e - Bias，e 为无符号数
      - M = 1 + f，f 为 face 的值
    - 非规格化的: exp 的位全为 0
      - E = 1 - Bias
      - M = f
    - 特殊值: exp 的位全为 1
      - frac 全为 0，时根据 s 表正负无穷大
      - frac 不为 0 时，表 NaN(Not a Number 不是一个数)
  - 精度
    - 单精度：k = 8，n = 23
    - 双精度：k = 11，n = 51
  - 舍入: 浮点运算只能近似的表示实数运算，通过传入找到最近似的值
    - 示例: 1.4 / 1.6 / 1.5 / 2.5 / -1.5
    - 向偶数舍入/最接近的值舍入(默认): 1 / 2 / 2 / 2 / -2
    - 向零舍入: 1 / 1 / 1 / 2 / -1
    - 向下舍入: 1 / 1 / 1 / 2 / -2
    - 向上舍入: 2 / 2 / 2 / 3 / -1

## 目标文件的执行

```cpp
#include <stdio.h>

int main()
{
  printf("hello word\n");
  return 0;
}
```

### 从源文件到目标文件

1. hello.c _源文件，文本_
2. hello.i _预处理器(cpp)修改原文件(修改#开头的文件)，文本_
3. hello.s _编译器(ccl)将 hello.i 翻译成 hello.s,翻译成汇编语言，文本_
4. hello.o _汇编器(as)将 hello.s 翻译成机器语言指令并打包成可重定位目标程序的格式，二进制文件_
5. hello _链接器(ld)将程序中的外部函数的预编译的目标文件合并得到可执行程序，二进制文件_

### 目标文件的执行过程(无缓存)

1. CPU 执行 shell 的指令,等待用户输入字符
2. 输入 hello.exe(each in 'hello.exe'：USB -> I/O 总线 -> I/O 桥 -> 系统总线 -> 总线接口 -> 寄存器文件 -> 总线接口 -> 系统总线 -> I/O 桥 -> 主存储器)
3. 通过直接存储器读取文件,将 hello.exe 的代码和数据复制到主存(磁盘控制器 -> I/O 桥 -> 内存总线 -> 主存设备)
4. 执行 man 函数的机器语言指令,将"hello word\n"，从主存复制到寄存器文件，再从寄存器文件复制到显示设备

- > **系统花费大量时间把信息从一个地方挪到另一个地方,减慢了程序的"真正"工作**
- > 根据机械原理：**较大的存储设备要比较小的存储设备运行的慢,而快速设备的造价远高于同类的低速设备**
- > **处理器从寄存器文件中读数据要比从主存中读数据快的多的多**
- > 系统设计者采用了更小更快的存储设备(高速缓存存储器)

## 异常控制流 ECF Exceptional Control Flow

> 当处理器检测到事件发生时，通过异常表(exception table)的跳转表，进行一个间接过程调用到异常处理程序(exception handler)

- 类别
  - 中断 来自I/O设备的信号 异步 例如网络适配器向处理器芯片的一个引脚发信号，并把异常号放到系统总线上
  - 陷阱 有意的异常 同步 主要是在用户程序和内核之间提供一个接口，也叫系统调用
    - 比如用户程序，读取一个文件，创建一个进程，加载一个程序，此时执行处理器提供的 syscall n，导致陷阱处理程序的运行
    - 用户的函数运行在用户模式，而系统调用运行在内核模式中
  - 故障 潜在可恢复的错误 同步
    - 如缺页异常，当指令引用的虚拟内存对应的物理页面不在内存中时，会发生故障，处理程序会从磁盘中加载
    - 如果处理程序不能修复这个问题，将返回到 abort 例程，abort 将终止应用程序
  - 终止 不可恢复的错误 同步
    - 如 RDAM 或 SRAM 位被损坏时
    - 直接交给 abort，abort 会终止应用程序

### 信号

> 更高层次的软件形式的异常，允许进程和内核中断其他进程

> 一种类型的信号只会有一个待处理信号，再次发送的将被丢弃（内核通过位向量来维护）

> 信号处理程序是和主程序和其他信号处理程序并发运行的

> 系统调用可以被信号中断，read/write/accept 这样的慢速系统调用时发生，如果因信号而中断，那么将不再继续而是返回错误，代码必须手动重启

- 发送信号 内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程
  - 内核检测到一个系统事件，比如除零错误或子进程终止
  - 一个进程调用了 kill 函数，显式的要求内核发送一个信号给目的进程
  - 常见的发送方式 
    - /bin/kill -9 15213 向 15231 进程组中的进程发送 9（SIGKILL）
    - Ctrl + C 发送 SIGINT
    - Ctrl + Z 发送 SIGTSTP
- 接收信号 目的进程被内核强迫以某种方式对信号做出反应
  - 内核将进程从内核模式切换回用户模式时，检查是否有未被阻塞的未处理信号（通常是最小的），如果有则强制进程接收该信号
  - 终止或通过执行一个信号处理程序的用户层函数捕获这个信号
  - 每个信号都有默认行为，以下的一种（可以通过函数改变）
    - 进程终止
    - 进程终止并转储内存
    - 进程停止（挂起）走到被 SIGCONT 重启
    - 进程忽略该信号
- 待处理信号 发出而没有被接口的信号
- 阻塞的信号
  - 进程可以有选择的阻塞接收某种信号
  - 信号被阻塞时，它仍可以被发送，但产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞
  - 机制
    - 隐式阻塞机制 内核默认阻塞当前在处理信号类型的待处理信号
    - 显式阻塞 使用 sigprocmask 相关的函数，明确的阻塞和解除阻塞选定的信号

### 非本地跳转

> 一种用户级异常控制流形式，从一个函数转到另一个当前正在执行的函数，而不需要经过正常的调用-返回程序

> C++ 和 Java 的异常机制是较高层次的，可看成为 setjmp/longjmp 更加结构化的版本，把 try cache 看成 setjmp，throw 类似于 longjmp 函数

- setjmp 
  - 在 env 缓冲区保存当前的调用环境供 longjmp 使用，包括程序计数器、栈指针和通用目的寄存器
- longjmp
  - 从 env 中恢复调用环境，然后触发从最近一次的 setjmp 的调用的返回，此时 setjmp 返回并有非 0 的返回值（setjmp 返回了两次）
  - 注意，如果中间函数调用中分配了某些数据结构，本该在结尾释放，如果中间发生跳转，会造成内存泄漏
- sigsetjmp/siglongjmp 可被信号处理程序使用的版本
- 应用
  - 遇到一个错误时，从一个深层嵌套的函数调用中立即返回
  - 使一个信号处理程序分支到一个特殊的代码位置，比如实现 Ctrl + C 来中断信号处理程序

## 虚拟内存

> 硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互

- 作为内存保护的工具: 保护每个进程的内存空间不被其他程序破坏
- 作为内存管理的工具: 为每个进程提供一致的地址空间
- 作为缓存的工作: 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并且根据需要在磁盘和主存间来回传送数据，以此高效的使用主存

---

- 虚拟内存被组织为一个存放在磁盘上的字节数组，虚拟地址为索引
- 物理地址(Physical Address) 主存的每个字节的地址
- 物理寻址(physical addressing) 使用物理地址寻址
- 虚拟地址(Virtual Address, VA) CPU 生成
- 地址翻译(address translation) 虚拟地址送到内存之前转换成适合的物理地址
- 内存管理单元(Memory Management Unit,MMU) CPU 芯片上的专用硬件，利用主存中的查询表来动态翻译虚拟地址
- 地址空间(address space) 非负整数地址的有序集合
- 线性地址空间（liner adderss space) 连续的地址空间
- 物理地址空间(physical address) 物理地址的集体
- 磁盘（较低层）和主存（较高层）使用块为传输单元
- 虚拟页(Virtual Page,VP) 虚拟内存划分的大小固定的块
  - 未分配的 VM 未分配的页，不占用磁盘空间
  - 缓存的 已缓存在物理内存中的已分配页
  - 未缓存的 未缓存在物理内存中的已分配页
- 物理页/页帧(Physical Page,PP) 物理内存划分的页
- 页表(page table) 存放在物理内存中，将虚拟内存映射到物理页，页表条目的数组
- 页表条目(Page Table Entry PTE) 物理页与虚拟页的映射的数据结构（每个虚拟页通过固定偏移找到页表条目）
  - 每个虚拟页通过固定偏移找到页表条目
  - 有效位，为 0 时页面就不在存储器中
  - 使用许可位来保护内存
   - SUP/READ/WRITE 是否必须在内核模式下(超级用户)才能访问/读/写
   - 如果指令违反许可位，CPU 将触发一般保护故障(linux 中一般为段错误 segmentation fault)
- 缺页(page fault) 主存缓存未命中 
- 工作集/常驻集合(working set) 程序趋向于在一个较小的活动页集体上工作
- 抖动(thrashing) 工作集的大小超出了物理内存的大小
- 内存映射(memory mapping) 将一组连续的虚拟页映射到任意一个文件的任意位置
- 简化共享
  - 为操作系统提供管理用户进程和操作系统自身的共享一致机制
  - 进程共享代码和数据，比如共享内核和C标准库的副本
- 简化内存分配 进程要求额外堆空间时，操作系统分配连续的虚拟页，并将它们映射到任意的物理页
- 后备缓冲器(Translation Lookaside Buffer TLB) MMU 中包括的小的缓存 PTE
  - 如果 TLB 中存在 PTE 则 MMU 省去向主存请求的过程
- 多级页表
  - 减少内存要求，如果一级页表中的一个 PTE 为空，二级页表根本就不存在
  - 一般只有一级页表和经常用的二级页表总是在主存中，减少了主存的压力
  - 设 32 位虚拟地址空间分配 4KB 的页，页表条目为 4字节
  - 一级页表每个 PTE 负责映射虚拟地址空间中的一个 4MB 的片
  - 二级页表每个 PTE 负责映射一个 4KB 的页

### 地址翻译

- 页表基址寄存器(Page Table Base Register PTRB)
- n 位的虚拟地址的构成
  - p 位的虚拟页面偏移(Virtual Page Offset VPO)
  - n-p 位的虚拟页号(Virtual Page Number VPN)
- 物理地址
  - 物理页号(Physical Page Number PPN)
  - 物理页偏移量(Physical Page Offset PPO)
- 注意 PPO 和 VPO 是相同的
- CPU 请求数据字
  1. CPU 生成一个虚拟地址，并送给 MMU
  2. MMU 生成 PTE 地址，并从主存中请求得到它
  3. 主存向 MMU 返回 PTE
  - 如果 PTE 中的有效位不为零(命中)
    - 4 MMU 构造物理地址，并传送给主存
    - 5 主存返回请求的数据字给 CPU
  - 如果 PTE 中的有效位为零(未命中)
    - 4 MMU 触发一次异常，传递 CPU 控制到缺页处理程序
    - 5 缺页处理程序确定出物理内存中的牺牲页，如果牺牲页已被修改则把它换出磁盘
    - 6 缺页处理程序调入新的页面，并更新内存中的 PTE
    - 7 缺页处理程序返回原来的进程，再次执行导致缺页的指令，CPU 将引起缺页的虚拟地址重新发给 MMU，此时命中并返回数据字
  
## 内存映射

- 将一个虚拟内存区域与一个磁盘上的对象关联，以初始化这个虚拟内存区域的内容
- 可映射到的对象
  - 普通磁盘文件
  - 匿名文件/请求二进制零的页 由内核创建
- 交换文件/交换空间/交换区域(swap file) 每个虚拟页初始化时，它会在内核专门维护的交换空间中传来传去，限制当前进程能分配虚拟页的总数
- 共享对象
  - 多个进程可以共享都需要的对象，如公共库函数，相同的代码区域
  - 当前进程的写对其他进程是可见的，且会反映在磁盘的原始对象中
  - 共享区域 共享对象映射的区域
- 私有对象
  - 当前进程的改变对其他进程是不可见的
  - 私有区域 私有对象映射的区域
  - 写时复制(copy-on-write)
    - 开始时和共享对象没有区别，页表条目被标识为只读，区域结构标记为私有的写时复制
    - 当某进程试图写时，触发一个保护故障
    - 故障处理程序会在物理内存中创建一个新副本，将更新页表条目指向这个新副本，然后恢复可写权限

### 动态内存分配

- 堆 动态内存分配器维护进程的虚拟内存区域
- 分配器
  - 显式分配器(explicit allocator) 应用显式的释放已分配的块
  - 隐式分配器(implicit allocator) 分配器检测一个已分配块何时不再使用，并释放它
    - 也叫 垃圾收集器(garbage collector)
    - 垃圾收集(grabage collection) 自动释放未使用的已分配的块的过程
  - 目标
    - 处理任意请求序列
    - 立即响应请求 因此不允许重新排列或缓冲请求(为了性能)
    - 只使用堆 为了可扩展
    - 对齐块 可以保存任何类型的数据对象
    - 不修改已分配的块
  - 碎片(fragmentation) 造成堆利用率低的主要原因
    - 内部碎片 已分配块的大小和它们的有效载荷之差的和
    - 外部碎片 当空闲内存合计能满足一个分配请求，但没有一个单独的空闲块足够大来处理这个请求
    - 外部碎片难以量化且不可能预测，通常采用启发式策略来试图维持少量的大块空闲
  - 当不能为分配请求找到合适的块时，通过合并在物理上相邻的空闲块来创建一些更大的空闲块，如果还不够则向内核请求额外的堆内存
  - 问题
    - 空闲块组织 如何记录空闲块
      - 隐式空闲列链表 空闲块通过头部中的大小字段隐含连接
        - 不适合作为通用的分配器，可能适合预先知道堆块数量的分配
        - 结构
          - 头部 编码块的大小，标记已分配位
          - 有效载荷 只包括已分配的块
          - 填充(可选) 满足对齐，对付外部碎片
      - 显式空闲列表 将空闲块组织为某种形式的显式数据结构，一般是双向链表
        - 指针可以存放在空闲块的主体中
        - 后进先出的顺序维护链表，将新释放的块放在链表的开始处
        - 按地址顺序维护链表，每个块的地址都小于它的后继地址
      - 分离的空闲链表
        - 大小类 将所有可能的块的大小分成一些等价类
        - 维护多个空闲链表，每个链表中的块有大致相等的大小
        - 简单分享存储
          - 所有空闲链表包含大小相等的块，块的大小是大小类中最大的
          - 分配时简单的分配第一块的全部，释放时直接插入前部
        - 分享适配
          - 分配器维护空闲链表的数组，每个空闲链表和一个大小类相关，并且被组织成隐式或显式的
          - 分配时找到合适或较大空闲链表
        - 伙伴系统
          - 每个大小类都是2的幂，开始时堆大小为 2^m 个字
          - 分配时为每个块大小 2^k 维护一个分享空闲列表，剩下的半块(也叫伙伴)放置在相应的空闲链表中
          - 释放时合并空闲链表中的伙伴，直到遇到一个已分配的块
    - 放置 如何选择一个合适的空闲块来旋转一个新分配的块
      - 首次适配(first fit)
        - 从头开始找到第一个合适的
      - 下一次适配(next fit)
        - 从上次的位置开始
      - 最佳适配(best fit)
        - 检查每个块，选择适合且最小的块
    - 分割 新的块被分配到某个空闲块后，如何处理空闲块的剩余部分
      - 使用整个块 会造成内部碎片
      - 将空闲块分为两部分，一部分变为已分配的，另一部分仍是空闲的
    - 合并 如何处理一个刚释放的块
      - 实际上分配器总是会合并相邻的空闲块
      - 假碎片(falut fragmentation) 许多可用的空闲块被切割为小的无法使用的空闲块
      - 何时合并
        - 立即合并 每次块被释放时合并相邻块
          - 会产生抖动，块被反复的合并然后马上分割
        - 推迟合并 稍晚的时候再合并
      - 边界合并 在每个块的结尾添加一个脚部，实际上是一个头部的副本
        - 将前面块的已分配/空闲位存放在当前块的多出来的低位中，那么已分配的块就不需要脚部了，不过空闲块仍需要脚部
- 垃圾收集器
  - 将内存视为一张有向可达图，节点被分为一组根节点和一组堆节点
  - 维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期回收它们
  - 当存在任意路径出发并到达 p 的有向路径时，表明节点 p 是可达的
  - 不可达的节点对应垃圾，是不能被应用再次使用的
  - Mark & Sweep 垃圾收集器（标记 & 清除）
    - 块头部中空闲的低位中的一位通常表示这个块是否被标记
    - 标记阶段标记出所有可达的和已分配的后继
    - 清除阶段释放每个未被标记的已分配块

## 同步线程

- 信号量
  - P(s) 
    - s <> 0 将 s-1 并立即返回
    - s == 0 将 挂起线程直到 s <> 0 
  - V(s) 将 s+1
    - 如果有线程阻塞在 P 则会重启一个线程
  - 互斥锁/二元信号量 将共享变量用 P 和 V 包围
  - 死锁 线程被阻塞且等待一个永远也不会为真的条件
- 线程安全 被多个并发线程反复调用也会产生正确的结果
- 可重入函数 被多个线程调用时，不会引用任何共享数据
- 竞争 程序的正确性依赖于一个线程要在另一个线程到达 y 前到达它的 x
