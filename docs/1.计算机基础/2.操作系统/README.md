# 操作系统

- **防止硬件被失控的应用程序滥用**
- **向而应用程序提供简单一致的机制来控制低级硬件设备**

> 操作系统通过进程、虚拟内存、文件来实现以上基本功能

## 进程

> 执行中程序的实例

- 进程提供给应用程序的关键抽象
  - 一个独立的逻辑控制流 好像程序独占地使用处理器
  - 一个私有的地址空间 好像程序独占地使用内存系统
- 逻辑控制流: PC 值的序列
- 进程上下文: 每个程序运行在一个进程上下文中，保存重启被抢占的进程所需的状态
  - 存放在内存的程序的代码和数据
  - 栈
  - 通用目的寄存器、浮点寄存器
  - 程序计数器
  - 环境变量
  - 打开文件描述符的集合等内核数据结构
- 抢占: 每个进程执行它的流的一部分，然后被抢占（暂时挂起）
- 时间片: 一个进程执行它的控制流的一部分的每一时间段
- 多任务/时间分片: 一个进程和其他进程轮流运行
- 并发: 逻辑流的执行在时间上与另一流重叠
- 用户模式和内核模式: 用某个寄存器的模式位实现，设置时为内核模式
  - 用户模式 
    - 不允许执行特权指令，如停止处理器，发起I/O操作，改变模式位
    - 不允许直接引用内核区的代码和数据
    - 必须通过系统调用接口间接的访问内核代码和数据
  - 内核模式
    - 应用程序必须使用中断、故障变为内核模式
    - linux 将许多内核数据结构的内容输入为用户可以读的文件层次结构（/proc）
- 调度: 进程执行时，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程
- 上下文切换: 调试时使用上下文切换，将控制转换到新线程
  - 内核使用的较高形式的异常控制流来实现多任务
  - 中断也可能会引发上下文切换，如周期性的定时器中断机制
  - 例
    - A进程执行系统调用read读取磁盘数据并陷入到内核
    - 内核此时代表进程A在用户模式下执行指令（没有单独的内核进程）
    - 陷阱处理程序请求磁盘的DMA数据
    - 内核代表，读取磁盘数据需要相对较长的时间，于是内核执行从A到B的上下文切换（内核从进程A的内核模式切换到进程B的内核模式），而不是什么都不干
    - 内核切换为用户模式，代表进程B执行指令
    - 磁盘发出中断信息，表示数据已传送到了内存
    - 内核判定进程B已运行足够的时间，执行从B到A的上下文切换
- 对应用来说进程的三种状态
  - 运行，要么在CPU上执行，要么在等待被执行且最终会被内核调度
  - 停止，线程的执行被挂起，且不会被调度
    - 当收到 SIGSTOP/SIGTSTP/SIGTTIN/SIGTTOU 进程就停止
    - 当收到 SIGCOUNT 时进程将再次运行
  - 终止
    - 从主程序返回
    - 调用 exit
    - 收到一个信号，该信号的默认行为是终止进程
- fork 父进程创建一个子进程
  - 子进程几乎与父进程一样，除了不同的 PID和私有的地址空间
  - 子进程终止时将保存在已终止状态，直到被父进程回收
    - 终止了但未被回收的进程称为僵死进程
  - 如果父进程终止那么内核会安排init进程代替父进程回收子进程

## 信号






### 上下文切换

> 内核使用的较高形式的异常控制流来实现多任务

- 内核为每个进程维护一个上下文，保存重启被抢占的进程所需的状态


- `进程`：**对一个正在运行的程序的抽象使程序看上去好像独占地使用处理器、主存、I/O 设备**
- `上下文`：**操作系统保持跟踪进程运行所需的所有状态信息**
- `并发运行`：**一个进程的指令和另一个进程的指令是交错执行的**
- `上下文切换`: **保存当前进程的上下文，恢复新进程的上下文，然后将控制权转给新进程**
- `系统内核`: **操作系统代码常驻主存部分，是系统管理全部进程所用代码和数据结构的集合**
- `线程`：**一个进程可以由多个线程的执行单元组成，都运行在进程的上下文中，并共享同样的代码和数据结构**
- `并发`：**同时具有多个活动的系统**
- `并行`：**并发来使系统运行的更快**

> Linux 中的进程相当于 Windows 中的线程

## 内存

- `虚拟内存`：**对程序存储器的抽象**
- `虚拟内存空间地址`：_进程看到的内存都是一致的，由大量准确定义的区构成，每个区都有专门的功能_
- `物理内存`：**实际上的内存**
- `物理内存空间地址`：**实际上的 RAM 内存条的空间**
- `驻留内存`：**被映射到虚拟内存空间的物理内存**
- `共享内存`：**被多个进程共享的内存**
- [存储器层次结构](/1.计算机基础/1.硬件.html#存储器层次结构)

### 虚拟内存

> 虚拟内存被组织成 N 个连续的字节大小的单元组成的数组，每字节都有唯一的虚拟地址，作为数组的索引。VM 系统将虚拟内存分割为虚拟页的大小固定的块，物理内存也被分为物理页。

> 物理页缓存在 L1、L2、L3 中，虚拟页缓存在主存中。

- `页表`：页表条目的数组用于将虚拟页映射到物理页
- `缺页`：读写取虚拟内存时，DRAM 不命中，触发缺页异常，调用内核异常处理程序，选择一个牺牲页，更新该页，重启导致缺页的命令
- **每当 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址**
- `碎片`：虽然有未使用的内存，但不能满足分配请求
- `内部碎片`：已分配块大小和它们的有效载荷大小之差的和
- `外部碎片`：当空闲内存合计可满足分配请求，但没有一个内存块足够大可以处理这个请求
- `空闲链表`：大多数分配器将边界、是否已分配的信息嵌入块本身，空闲块通过头部中的大小字段隐含连接
- `DRAM`：常驻内存的页表
- `CPU访问主存`：_CPU 提供虚拟内存地址，通过地址翻译来定位 DRAM 中的列表条目，如果不命中(也叫缺页)则触发缺页异常，调用内核异常处理程序，选择一个牺牲页，更新该页并重启导致缺页的命令，命中列表条目，得到物理地址_
- `共享物理页面`：_被多个虚拟地址空间映射_

> 操作系统为每个进程提供了独立的页面也就是提供了独立的虚拟地址空间

#### 虚拟内存地址空间(按区分配)

- **内核虚拟内存** _顶级区域,隐藏_
- **用户栈** _编译器用它来实现函数调用(每调用一个函数，栈就增长，从一个函数返回时，栈就减少)_
- **共享库** _存放像 C 标准库和数学库这样的共享库的代码和数据的区域_
- **运行时堆** _存放运行时的数据_
- **程序代码和数据** _进程开始运行时按照可执行目标文件的内容初始化_
- **0**

> Linux 不共享内核虚拟内存
