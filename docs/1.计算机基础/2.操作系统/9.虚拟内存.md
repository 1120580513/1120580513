# 虚拟内存

> 硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互

- 作为内存保护的工具: 保护每个进程的内存空间不被其他程序破坏
- 作为内存管理的工具: 为每个进程提供一致的地址空间
- 作为缓存的工作: 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并且根据需要在磁盘和主存间来回传送数据，以此高效的使用主存

---

- 虚拟内存被组织为一个存放在磁盘上的字节数组，虚拟地址为索引
- 物理地址(Physical Address) 主存的每个字节的地址
- 物理寻址(physical addressing) 使用物理地址寻址
- 虚拟地址(Virtual Address, VA) CPU 生成
- 地址翻译(address translation) 虚拟地址送到内存之前转换成适合的物理地址
- 内存管理单元(Memory Management Unit,MMU) CPU 芯片上的专用硬件，利用主存中的查询表来动态翻译虚拟地址
- 地址空间(address space) 非负整数地址的有序集合
- 线性地址空间（liner adderss space) 连续的地址空间
- 物理地址空间(physical address) 物理地址的集体
- 磁盘（较低层）和主存（较高层）使用块为传输单元
- 虚拟页(Virtual Page,VP) 虚拟内存划分的大小固定的块
  - 未分配的 VM 未分配的页，不占用磁盘空间
  - 缓存的 已缓存在物理内存中的已分配页
  - 未缓存的 未缓存在物理内存中的已分配页
- 物理页/页帧(Physical Page,PP) 物理内存划分的页
- 页表(page table) 存放在物理内存中，将虚拟内存映射到物理页，页表条目的数组
- 页表条目(Page Table Entry PTE) 物理页与虚拟页的映射的数据结构（每个虚拟页通过固定偏移找到页表条目）
  - 每个虚拟页通过固定偏移找到页表条目
  - 有效位，为 0 时页面就不在存储器中
  - 使用许可位来保护内存
   - SUP/READ/WRITE 是否必须在内核模式下(超级用户)才能访问/读/写
   - 如果指令违反许可位，CPU 将触发一般保护故障(linux 中一般为段错误 segmentation fault)
- 缺页(page fault) 主存缓存未命中 
- 工作集/常驻集合(working set) 程序趋向于在一个较小的活动页集体上工作
- 抖动(thrashing) 工作集的大小超出了物理内存的大小
- 内存映射(memory mapping) 将一组连续的虚拟页映射到任意一个文件的任意位置
- 简化共享
  - 为操作系统提供管理用户进程和操作系统自身的共享一致机制
  - 进程共享代码和数据，比如共享内核和C标准库的副本
- 简化内存分配 进程要求额外堆空间时，操作系统分配连续的虚拟页，并将它们映射到任意的物理页
- 后备缓冲器(Translation Lookaside Buffer TLB) MMU 中包括的小的缓存 PTE
  - 如果 TLB 中存在 PTE 则 MMU 省去向主存请求的过程
- 多级页表
  - 减少内存要求，如果一级页表中的一个 PTE 为空，二级页表根本就不存在
  - 一般只有一级页表和经常用的二级页表总是在主存中，减少了主存的压力
  - 设 32 位虚拟地址空间分配 4KB 的页，页表条目为 4字节
  - 一级页表每个 PTE 负责映射虚拟地址空间中的一个 4MB 的片
  - 二级页表每个 PTE 负责映射一个 4KB 的页

## 地址翻译

- 页表基址寄存器(Page Table Base Register PTRB)
- n 位的虚拟地址的构成
  - p 位的虚拟页面偏移(Virtual Page Offset VPO)
  - n-p 位的虚拟页号(Virtual Page Number VPN)
- 物理地址
  - 物理页号(Physical Page Number PPN)
  - 物理页偏移量(Physical Page Offset PPO)
- 注意 PPO 和 VPO 是相同的
- CPU 请求数据字
  1. CPU 生成一个虚拟地址，并送给 MMU
  2. MMU 生成 PTE 地址，并从主存中请求得到它
  3. 主存向 MMU 返回 PTE
  - 如果 PTE 中的有效位不为零(命中)
    - 4 MMU 构造物理地址，并传送给主存
    - 5 主存返回请求的数据字给 CPU
  - 如果 PTE 中的有效位为零(未命中)
    - 4 MMU 触发一次异常，传递 CPU 控制到缺页处理程序
    - 5 缺页处理程序确定出物理内存中的牺牲页，如果牺牲页已被修改则把它换出磁盘
    - 6 缺页处理程序调入新的页面，并更新内存中的 PTE
    - 7 缺页处理程序返回原来的进程，再次执行导致缺页的指令，CPU 将引起缺页的虚拟地址重新发给 MMU，此时命中并返回数据字
  
## 内存映射

- 将一个虚拟内存区域与一个磁盘上的对象关联，以初始化这个虚拟内存区域的内容
- 可映射到的对象
  - 普通磁盘文件
  - 匿名文件/请求二进制零的页 由内核创建
- 交换文件/交换空间/交换区域(swap file) 每个虚拟页初始化时，它会在内核专门维护的交换空间中传来传去，限制当前进程能分配虚拟页的总数
- 共享对象
  - 多个进程可以共享都需要的对象，如公共库函数，相同的代码区域
  - 当前进程的写对其他进程是可见的，且会反映在磁盘的原始对象中
  - 共享区域 共享对象映射的区域
- 私有对象
  - 当前进程的改变对其他进程是不可见的
  - 私有区域 私有对象映射的区域
  - 写时复制(copy-on-write)
    - 开始时和共享对象没有区别，页表条目被标识为只读，区域结构标记为私有的写时复制
    - 当某进程试图写时，触发一个保护故障
    - 故障处理程序会在物理内存中创建一个新副本，将更新页表条目指向这个新副本，然后恢复可写权限

## 动态内存分配

- 堆 动态内存分配器维护进程的虚拟内存区域
- 分配器
  - 显式分配器(explicit allocator) 应用显式的释放已分配的块
  - 隐式分配器(implicit allocator) 分配器检测一个已分配块何时不再使用，并释放它
    - 也叫 垃圾收集器(garbage collector)
    - 垃圾收集(grabage collection) 自动释放未使用的已分配的块的过程
  - 目标
    - 处理任意请求序列
    - 立即响应请求 因此不允许重新排列或缓冲请求(为了性能)
    - 只使用堆 为了可扩展
    - 对齐块 可以保存任何类型的数据对象
    - 不修改已分配的块
  - 碎片(fragmentation) 造成堆利用率低的主要原因
    - 内部碎片 已分配块的大小和它们的有效载荷之差的和
    - 外部碎片 当空闲内存合计能满足一个分配请求，但没有一个单独的空闲块足够大来处理这个请求
    - 外部碎片难以量化且不可能预测，通常采用启发式策略来试图维持少量的大块空闲
  - 当不能为分配请求找到合适的块时，通过合并在物理上相邻的空闲块来创建一些更大的空闲块，如果还不够则向内核请求额外的堆内存
  - 问题
    - 空闲块组织 如何记录空闲块
      - 隐式空闲列链表 空闲块通过头部中的大小字段隐含连接
        - 不适合作为通用的分配器，可能适合预先知道堆块数量的分配
        - 结构
          - 头部 编码块的大小，标记已分配位
          - 有效载荷 只包括已分配的块
          - 填充(可选) 满足对齐，对付外部碎片
      - 显式空闲列表 将空闲块组织为某种形式的显式数据结构，一般是双向链表
        - 指针可以存放在空闲块的主体中
        - 后进先出的顺序维护链表，将新释放的块放在链表的开始处
        - 按地址顺序维护链表，每个块的地址都小于它的后继地址
      - 分离的空闲链表
        - 大小类 将所有可能的块的大小分成一些等价类
        - 维护多个空闲链表，每个链表中的块有大致相等的大小
        - 简单分享存储
          - 所有空闲链表包含大小相等的块，块的大小是大小类中最大的
          - 分配时简单的分配第一块的全部，释放时直接插入前部
        - 分享适配
          - 分配器维护空闲链表的数组，每个空闲链表和一个大小类相关，并且被组织成隐式或显式的
          - 分配时找到合适或较大空闲链表
        - 伙伴系统
          - 每个大小类都是2的幂，开始时堆大小为 2^m 个字
          - 分配时为每个块大小 2^k 维护一个分享空闲列表，剩下的半块(也叫伙伴)放置在相应的空闲链表中
          - 释放时合并空闲链表中的伙伴，直到遇到一个已分配的块
    - 放置 如何选择一个合适的空闲块来旋转一个新分配的块
      - 首次适配(first fit)
        - 从头开始找到第一个合适的
      - 下一次适配(next fit)
        - 从上次的位置开始
      - 最佳适配(best fit)
        - 检查每个块，选择适合且最小的块
    - 分割 新的块被分配到某个空闲块后，如何处理空闲块的剩余部分
      - 使用整个块 会造成内部碎片
      - 将空闲块分为两部分，一部分变为已分配的，另一部分仍是空闲的
    - 合并 如何处理一个刚释放的块
      - 实际上分配器总是会合并相邻的空闲块
      - 假碎片(falut fragmentation) 许多可用的空闲块被切割为小的无法使用的空闲块
      - 何时合并
        - 立即合并 每次块被释放时合并相邻块
          - 会产生抖动，块被反复的合并然后马上分割
        - 推迟合并 稍晚的时候再合并
      - 边界合并 在每个块的结尾添加一个脚部，实际上是一个头部的副本
        - 将前面块的已分配/空闲位存放在当前块的多出来的低位中，那么已分配的块就不需要脚部了，不过空闲块仍需要脚部
- 垃圾收集器
  - 将内存视为一张有向可达图，节点被分为一组根节点和一组堆节点
  - 维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期回收它们
  - 当存在任意路径出发并到达 p 的有向路径时，表明节点 p 是可达的
  - 不可达的节点对应垃圾，是不能被应用再次使用的
  - Mark & Sweep 垃圾收集器（标记 & 清除）
    - 块头部中空闲的低位中的一位通常表示这个块是否被标记
    - 标记阶段标记出所有可达的和已分配的后继
    - 清除阶段释放每个未被标记的已分配块

