# 程序结构和执行

## 信息的表示和处理

- **小端法** _最低有效字节在前面_
- **大端法** _最低有效字节在后面_
---
- byte 字节: 8位，作为最小的可寻址的内存单位
- word size 字长: 虚拟地址以一个字来编码，决定虚拟地址空间大小
---
- Unicode: 文字编码标准
- UTF-8: 将每个字符编码为一个字节序列

### 整数有符号位的表示 

- 原码: 最高位表示符号位，人最容易理解
- 反码: 正数的反码是其本身，负数的反码是除符号位不变，其他位取反
- 补码: 正数的补码是其本身，负数的补码在反码的基础上 +1 

> 为了让加减乘除尽可能的简单，如加法转换为加一个负数，想到可以将符号位参与运算。此时原码直接计算是不正确的，而反码在表示 0 时会有两种情况，所以通常都使用补码。

> 整数运算实际上是一种模运算，表示数据的长度限制了取值的范围。

### 浮点籹 

- 二进制小数: 小数值是不精确的，只能通过增加长度来提高精度
  - 点的左边的位的权是2的正幂，右边的权是2的负幂
    - 101.11(二进制) = 4*1 + 2*0 + 1*1 + 1/2*1 + 1/4*1 = 5又3/4 = 5.75(十进制)
- IEEE(电气和电子工程师协会)浮点数
  - 公式: (-1)^s * M * 2^E
    - 符号(s): (-1)^s，决定这个数是正数还是负数
    - 阶码(exp): 2^E，可能是负数，对浮点数加权，权重是 2^E
    - 尾数(frac): M，二进制小数
    - s: 符号位
    - expa：k 位的阶码字段
    - frac：n 位的小数字段
    - Biasa: 2^(k-1) - 1
    - 被编码的值的三种情况(根据 exp 的值)
    - 规格化的: exp 的位即不都为 0 也不都为 1
      - E = e - Bias，e 为无符号数
      - M = 1 + f，f 为 face 的值
    - 非规格化的: exp 的位全为 0
      - E = 1 - Bias
      - M = f
    - 特殊值: exp 的位全为 1
      - frac 全为 0，时根据 s 表正负无穷大
      - frac 不为 0 时，表 NaN(Not a Number 不是一个数)
  - 精度
    - 单精度：k = 8，n = 23
    - 双精度：k = 11，n = 51
  - 舍入: 浮点运算只能近似的表示实数运算，通过传入找到最近似的值
    - 示例: 1.4 / 1.6 / 1.5 / 2.5 / -1.5
    - 向偶数舍入/最接近的值舍入(默认): 1 / 2 / 2 / 2 / -2
    - 向零舍入: 1 / 1 / 1 / 2 / -1
    - 向下舍入: 1 / 1 / 1 / 2 / -2
    - 向上舍入: 2 / 2 / 2 / 3 / -1

## 目标文件的执行

```cpp
#include <stdio.h>

int main()
{
  printf("hello word\n");
  return 0;
}
```

### 从源文件到目标文件

1. hello.c _源文件，文本_
2. hello.i _预处理器(cpp)修改原文件(修改#开头的文件)，文本_
3. hello.s _编译器(ccl)将 hello.i 翻译成 hello.s,翻译成汇编语言，文本_
4. hello.o _汇编器(as)将 hello.s 翻译成机器语言指令并打包成可重定位目标程序的格式，二进制文件_
5. hello _链接器(ld)将程序中的外部函数的预编译的目标文件合并得到可执行程序，二进制文件_

### 目标文件的执行过程(无缓存)

1. CPU 执行 shell 的指令,等待用户输入字符
2. 输入 hello.exe(each in 'hello.exe'：USB -> I/O 总线 -> I/O 桥 -> 系统总线 -> 总线接口 -> 寄存器文件 -> 总线接口 -> 系统总线 -> I/O 桥 -> 主存储器)
3. 通过直接存储器读取文件,将 hello.exe 的代码和数据复制到主存(磁盘控制器 -> I/O 桥 -> 内存总线 -> 主存设备)
4. 执行 man 函数的机器语言指令,将"hello word\n"，从主存复制到寄存器文件，再从寄存器文件复制到显示设备

- > **系统花费大量时间把信息从一个地方挪到另一个地方,减慢了程序的"真正"工作**
- > 根据机械原理：**较大的存储设备要比较小的存储设备运行的慢,而快速设备的造价远高于同类的低速设备**
- > **处理器从寄存器文件中读数据要比从主存中读数据快的多的多**
- > 系统设计者采用了更小更快的存储设备(高速缓存存储器)
