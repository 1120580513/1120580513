# DB

- OLTP On-Line Transaction Processing 联机事务处理
  - 事务性非常高的系统，以小的事务和小的查询为主，一般是高可用的在线系统
  - 重点关注每秒执行的事务以及执行的SQL数量 
  - 瓶颈易在CPU和磁盘系统
    - CPU 瓶颈主要因逻辑读总量与计算性函数或过程上
    - 磁盘瓶颈取决于IOPS(Input/Ouput Per Secound 每秒读写数)
  - 优化（使用缓存，并发量高，快速提交，避免阻塞）
    - 使用绑定变量，减少语句解析
    - 索引的使用，相关语句越简单越好
    - 减少表关联、分布式事务
    - 尽量不使用分区、物化视图、并行、位图索引
- OLAP On-Line Analytical Processing 联机分析处理（数据仓库）
  - 重点关注磁盘子秕的吞吐量，因为语句的执行可能会很长，读取的数据也多
  - 内存上的优化余地很小，增加 CPU处理速度和磁盘I/O可快速提高性能
  - 不需要使用绑定变量，因为执行量较小，分析时间对于执行时间来说可忽略
  - 使用分区方便管理，并行提升效率
- 在设计时要注意不要盲目的使用另一个数据处理的技术


## 事务

- 原子性（Atomicity）
  - 所有的操作要么成功要么失败
- 一致性（Consistency）
  - 事务前后数据的一致性状态不被破坏
- 隔离性（Isolation）
  - 并发事务间互不干扰，一个事务不能看到另一个的中间状态
- 持久性（Durability）
  - 提交事务的结果对数据的改变是永久性的

### 隔离级别

- 脏读 一个事务处理中读取了另一个未提交事务的数据
- 不可重复读 一个事务内的多次查询返回了不同的数据值
- 幻读/虚读 A对某表所有数据执行修改，B插入了一条数据，A提交后发现有一条数据未修改（B插入的那条）

---

- `未提交读（READ UNCOMMITTED）`：事务中的修改，即使没有提交，对其它事务也是可见的。最低级别，任何情况都无法保证。
- `提交读（READCOMMITTED）`：一个事务只能读取已经提交的事务所做的修改。句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可避免脏读的发生。（Sql Server、Oracle 默认级别）
- `可重复读（REPEATABLEREAD）`：保证在同一个事务中多次读取同样数据的结果是一样的。可避免脏读、不可重复读的发生。（MySql 默认级别）
- `可串行化（SERIALIXABLE）`：强制事务串行执行。可避免脏读、不可重复读、幻读的发生。

### 隔离性的作用

- `脏读`：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- `不可重复读`：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- `虚读(幻读)`：幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。

## NoSQL（Not Only SQL）

- 关系数据库存储的是行记录，无法存储数据结构
- 关系数据库的结构扩展很不方便
- 关系数据库在大数据场景下 I/O 较高
- 关系数据库的全文搜索功能比较弱

> 针对以上问题，分别诞生了不同的 NoSQL 解决方案，在某些应用场景下表现更好。但 NoSQL 方案带来的优势，本质上是牺牲 ACID 中的某个或者某几个特性带来的

- _K-v 存储_：解决关系数据库无法存储数据结构的问题，以`Redis`为代表
  > `Redis`只保证隔离性和一致性
- _文档数据库_：解决关系数据库强结构约束的问题，以`MongoDB`为代表
  > `MongoDB`新增字段简单、历史数据不会出错、容易存储复杂结构，但不支持事务，无法 Join
- _列式数据库_：解决关系数据库大数据场景下的 I/O 问题，以`HBase`为代表
  > `HBase`按列存储，一般应用在离线的大数据分析和统计场景中
- _全文搜索引擎_：解决关系数据库的全文搜索性能问题，以`Elasticsearch`为代表
  > `Elasticsearch`索引的对象是单词和文档，每个字段都会有专用的倒排索引

## 三大范式([详细](https://blog.csdn.net/dove_knowledge/article/details/71434960))

1. 确保每列保持原子性
2. 在`1NF`的前提下确保表中的每列都和主键相关
3. 在`2NF`的前提下确保每列都和主键列直接相关,而不是间接相关
