# DB

## 工具

- DBeaver

## DBMS

> `Oracle` `MySQL` `MSSQL` `PostgreSQL` `DB2` `Access` `SQLite` `Sybase`

### 缺点

- 关系数据库存储的是行记录，无法存储数据结构
- 关系数据库的结构扩展很不方便
- 关系数据库在大数据场景下 I/O 较高
- 关系数据库的全文搜索功能比较弱

> 针对以上问题，分别诞生了不同的 NoSQL 解决方案，在某些应用场景下表现更好。但 NoSQL 方案带来的优势，本质上是牺牲 ACID 中的某个或者某几个特性带来的

## NoSQL（Not Only SQL）

> `CouchDB` `Redis` `MongoDB` `Riak` `Membase` `Neo4j` `Cassandra` `HBase` `Elasticsearch`

### 常见分类

- _K-v 存储_：解决关系数据库无法存储数据结构的问题，以`Redis`为代表
  > `Redis`只保证隔离性和一致性
- _文档数据库_：解决关系数据库强结构约束的问题，以`MongoDB`为代表
  > `MongoDB`新增字段简单、历史数据不会出错、容易存储复杂结构，但不支持事务，无法 Join
- _列式数据库_：解决关系数据库大数据场景下的 I/O 问题，以`HBase`为代表
  > `HBase`按列存储，一般应用在离线的大数据分析和统计场景中
- _全文搜索引擎_：解决关系数据库的全文搜索性能问题，以`Elasticsearch`为代表
  > `Elasticsearch`索引的对象是单词和文档，每个字段都会有专用的倒排索引

## 默认端口

- **Oracle** _1521_
- **MySQL** _1433_
- **MSSQL** _3306_
- **PostgreSQL** _5432_
- **DB2** _5000_
- **Sybase** _5000_
- **Redis** _6379_
- **MongoDB** _27017_

## 三大范式([详细](https://blog.csdn.net/dove_knowledge/article/details/71434960))

1. 确保每列保持原子性
2. 在`1NF`的前提下确保表中的每列都和主键相关
3. 在`2NF`的前提下确保每列都和主键列直接相关,而不是间接相关

## 事务([源](https://www.cnblogs.com/fjdingsd/p/5273008.html))

- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

### 隔离级别

- `未提交读（READ UNCOMMITTED）`：事务中的修改，即使没有提交，对其它事务也是可见的。最低级别，任何情况都无法保证。
- `提交读（READCOMMITTED）`：一个事务只能读取已经提交的事务所做的修改。句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可避免脏读的发生。（Sql Server、Oracle 默认级别）
- `可重复读（REPEATABLEREAD）`：保证在同一个事务中多次读取同样数据的结果是一样的。可避免脏读、不可重复读的发生。（MySql 默认级别）
- `可串行化（SERIALIXABLE）`：强制事务串行执行。可避免脏读、不可重复读、幻读的发生。

### 隔离性的作用

- `脏读`：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- `不可重复读`：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- `虚读(幻读)`：幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。

## 缓存

### 穿透

> 指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据

1. 被访问的数据确实不存在，一般将空值也缓存
2. 访问时缓存刚好失效，这种情况并没有太好的解决方案

### 雪崩

> 是指当缓存失效（过期）后引起系统性能急剧下降的情况

1. 当缓存失效时，多个线程同时更新缓存，一般对缓存更新操作设置一个更新锁，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值
2. 当缓存内存不够时，会踢掉部分缓存，这里业务系统不知道该缓存已被踢掉，拿到空数据，一般由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存

## RDBMS 表常用命名

> {业务名称}_{表的作用}

| 前缀 |  | 
| :-----| :---- | 
| tb_ | 业务表 |
| tr_ | 关系表 |
| th_ | 历史表 |
| ts_ | 统计表 |
| tl_xxx_log | 日志表 |